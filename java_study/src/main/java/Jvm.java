public class Jvm {
    public static void main(String[] args) {

        /**
         *
         * 一、虚拟机栈：
         * 1、每个线程都有自己的栈空间，线程间互相独立。
         * 2、栈空间可扩展也可固定，可扩展条件下如果内存不够扩展，会出现OutOfMemoryError异常；固定条件下，内存不够报StackOverFlow异常
         * 3、栈中的数据以栈帧（stack frame）的形式存储，对应线程上正在执行的方法。一个方法对应一个栈帧。
         * 4、栈帧是一个内存区块，存储方法执行中的数据集（指令集）：
         *    1）局部（本地)变量表；
         *    2）操作数栈（或表达式栈）；
         *    3）动态链接（或指向常量池的方法引用）
         *    4）调用的方法返回地址（正常退出或异常退出）
         *    5）其他附加信息
         * 5、方法调用时，会增加栈帧。栈顶方法执行完毕后结果会返回给调用者（前一个栈帧）
         * -xss: 设置栈空间大小，linux64、mac默认1024k、windows取决于虚拟机内存。
         * Sets the thread stack size (in bytes). Append the letter k or K to indicate KB, m or M to indicate MB, g or G to indicate GB.
         * -Xss1m
         * -Xss1024k
         * -Xss1048576
         *
         * （一）局部变量表：
         * 1、是一个数字数组，存储：方法参数、定义在方法内的局部变量（基本数据类型、对象引用、返回值地址等）
         * 2、存在栈上不存在数据安全问题。
         * 3、所需容量大小在编译期间就已经确定下来
         * 4、只在当前方法中有效
         * 5、以数字数字形式存放，基本存储单元是slot（槽），long和double类型占两个slot，其他为一个slot。一个slot有一个索引，两个slot数据使用首个索引进行访问
         * 6、不同于类变量，局部变量必须显式赋值，否则无法使用
         * 7、在栈帧中，局部变量表是性能调优最为密切的部分
         *
         * （二）操作数栈
         * 1、缓存方法的操作指令（字节码指令）结果，使用数组结构实现栈操作
         * 2、主要用于保存计算过程的中间结果，也作为计算过程中变量的临时存放空间
         * 3、在方法执行时，一个栈帧会被创建，但其中操作数栈为空，但长度确定，在编译期间即被确定
         *
         * （三）动态链接
         * 1、每一个栈帧内部都包含一个指向运行时常量池中所属方法的引用
         * 2、在编译后的字节码文件中，所有变量和方法的引用都作为符号引用保存在常量池中（运行后位置为方法区常量池，即运行时常量池）。
         * 3、静态链接：编译期间就可以确定的链接引用。即固定的引用绑定
         * 4、动态链接：编译时不确定的引用，如子类调用、接口调用等
         *
         * 5、虚方法：编译期间无法确定所属类的方法，如调用接口函数，而接口尚未实现（字节码中invokeVirtual指令调用，接口抽象方法调用为invokeInterface调用）
         * 6、非虚方法：确定的方法，无法被改写的方法，如静态方法、私有方法、final方法、构造器、父类方法等（invokeStatic、invokeSpecial调用；final修饰符为invokeVirtual调用 ）
         * 7、函数式接口，lambda表达时调用时使用invokeDynamic指令调用
         * 8、为了提高性能，减少每次虚方法执行时的向上检索，jvm通过虚方法表来记录执行时虚方法的直接引用
         *
         * （四）方法返回地址
         * 1、存放该方法的pc寄存器的值
         * 2、正常执行或异常执行都导致返回
         */

        //====================================
        /**
         * 二、本地方法（native method）接口
         * 1、由非java语言实现的（c/c++语言）
         * 2、native关键字修饰的方法，无方法体 ，无法重写
         *
         * 三、本地方法栈
         * 1、用于管理本地方法的调用
         * 2、线程私有的
         * 3、同样会报栈异常
         * 4、本地方法不受虚拟机限制，但权限和虚拟机相同
         * 5、本地方法可以通过本地接口访问运行时数据区
         * 6、在hotspot jvm中本地方法栈和虚拟机栈合并
         */

        //====================================
        /**
         * 四、堆空间（重要）
         * 1、一个jvm实例只有一个堆内存，也是内存管理的核心区域
         * 2、在jvm启动时就创建，其空间大小也就确定了 ，是jvm中最大的内存区
         * 3、堆内存大小可调节
         * 4、可以划分线程私有的缓冲区
         * 5、所有的对象实例和数据都应该分配到堆内存中（栈帧中保存引用）
         * 6、堆空间从逻辑上可以划分为：新生区、老年区、永久区（元空间-jdk8）。永久区也可以不作为堆空间（比较独立）
         *
         * 堆空间设置：
         * -xms10m  用于设置堆空间的起始内存大小，等价于-xx:InitialHeapSize。默认是电脑内存的1/64
         * -xmx10m  表示堆空间可用的最大内存大小，等价于-xx:MaxHeapSize。超过改值时，会会报OutOfMemoryError错误（OOM），默认值为电脑内存的1/4
         * 建议以上两个参数设置为相同的值。避免频繁扩容和释放
         * -xx:PrintGCDetails 会在日志中打印jvm信息
         */

        long currentMemory = Runtime.getRuntime().totalMemory();  //返回堆内存总量
        long xmx = Runtime.getRuntime().maxMemory();  //返回最大堆空间内存

    }
}
