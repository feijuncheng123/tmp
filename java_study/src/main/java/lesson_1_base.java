


/*
基本语法:
一个源文件中最多只能有一个public类。其它类的个数不限，如果源文件包含一个public类，则文件名必须按该类名命名。
Java语言严格区分大小写。
Java方法由一条条语句构成，每个语句以“;”结束。
 */

public class lesson_1_base {
  public static void main(String[] args) {
    //关键词：
    //关键字中所有字母都是小写的
    System.out.println("");

    //Java中的名称命名规范：
    //包名：多单词组成时所有字母都小写：xxxyyyzzz
    //类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz
    //变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz
    //常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ

    //基本数据类型:全部存放于栈空间中。
    //1、数值型：
    //byte: 1字节=8bit -128 ~ 127
    //short: 2字节     -215 ~215-1
    //int: 4字节       -231 ~ 231-1   默认
    //long: 8字节      -263 ~ 263-1   定义时需要加上L后缀
    //2、浮点型(float,double)：
    //单精度float：4字节，须后加‘f’或‘F’
    //双精度double： 8字节。不加f则默认为double

    //3、字符型：
    //char：单引号，仅能标识一个字符（英文、中文、标点符号、日文、特殊符号（换行符、制表符等，需要用转义字符\进行转义等）

    //4、布尔型：
    //只允许取值true和false，不能取null；不能用0或者1替代；


    //引用数据类型：数据存放于堆空间中，栈空间中存放堆数据的内存引用
    // 类（字符串）
    // 接口
    // 数组

    //类型转换：
    // 自动类型转换：容量小的类型自动转换为容量大的数据类型。int->long->float->double
    // 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算
    // byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型
    //当把任何基本类型的值和字符串值进行连接运算时(+)，基本类型的值将自动转化为字符串类型。

    //强制类型转换：容量大的转换为容量小的；
    //使用时要加上强制转换符（()），但可能造成精度降低或溢出
    long l=12234L;
    int i=(int)l;


    System.out.println("Hello"+'a'+1);

    //算数运算符：
    // +（加或者正号）、-（减或者负号）、*、/
    //除法：整数之间做除法时，只保留整数部分而舍弃小数部分。需要将其中之一转化为double；
    double db = 100/3; //结果为33.0
    // % 取模，7%5=2。如果分子7为负值，则结果为负值，如果分母5为负数，则忽略不计，不会影响结果
    // ++ 自增1（值前）：先运算后取值；自增1（值后）：先取值后运算
    // -- 自减，同上
    int a=2; int b=++a;  //结果：a=3;b=3
    int c=2; int d=c++;  //结果：a=3;b=2

    int x=0; x = x++;  //执行后x仍然为0. x=x++在底层执行时相当于int temp=x, x= x+1; x=temp，重新赋值回原来的值。
    //先返回x++,在返回赋值。读->改->写

    //赋值运算符：=
    //当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理
    //支持连续赋值。
    //扩展赋值运算符： +=, -=, *=, /=, %=
    short  s1=12;
    s1 = s1 + 3; //是错误的，原因是加3转化为了int类型，在赋值给short类型。除非加上强转。
    s1 = (short)(s1 + 3) ; //代价很大，不能这样写
    s1 += 3; //只能这样写，不会更改原来的类型

    int i1=3;
    i1 *= 0.1; //结果是i1为0。保持原有类型


    //比较运算符：比较运算符的结果都是boolean型，也就是要么是true，要么是false
    // < , > , ==  , != ,  <= , >=
    // instanceof :检查是否是类的对象
    boolean b1= "hello" instanceof String;

    //逻辑运算符:
    // & : 并且； 多条件时全部进行计算，即使前一个条件不满足，后一个条件也会计算；
    // | ： 或者 ； 计算同&
    // ！ ： 非
    // && ： 效果同 &； 只要检测到一个条件不满足，就会终止计算后续条件； 建议使用，节省计算，且少异常
    // || ； 效果同 | ；计算同&&； 建议使用，节省计算，且少异常
    // ^ ：异或 ，不一致为true，一致为false

    //位运算符：略

    //三元运算符：
    // (条件表达式)? 表达式1：表达式2； 条件为true运行表达式1，否则运行2；
    // 表达式1和表达式2 必须为同一数据类型
    int a1= (a>b)?a:b;
    String s2= (a > b)?"a最大":(a > c)?"b最大":"a最小";



  }
}
